<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[不好意思，观察者模式跟发布订阅模式就是不一样]]></title>
    <url>%2F2018%2F05%2F08%2F%E4%B8%8D%E5%A5%BD%E6%84%8F%E6%80%9D%EF%BC%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E8%B7%9F%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%B0%B1%E6%98%AF%E4%B8%8D%E4%B8%80%E6%A0%B7%2F</url>
    <content type="text"><![CDATA[一、前言一天，小猪佩奇去了一家西餐厅，点了一份西冷牛扒，还叫了圣女果。后来服务员上了一碟番茄，佩奇小姐：这是你的「圣女果」。佩奇猪一眼就看出了猫腻：这tm是番茄，不是圣女果啊！于是就跟服务员理论起来：这是番茄不是圣女果，不是！服务员一脸懵逼：番茄不就是圣女果吗？…佩奇猪一脸「黑人问号」了：番茄是菜，圣女果是水果，这能一样？？？观察者模式与发布/订阅模式大概就跟番茄与圣女果的关系一样，剪不断理还乱。也许，我们也听过两种模式之间的一些区别，但我相信，大部分的人对其中差异的感知还是很弱的。在JavaScript里，Observer模式通常被我们用Publish/Subscribe模式来实现，不可否认这些模式很相似，但它们还是有很本质的区别！二、观察者模式与发布/订阅模式的区别通过一张图来宏观了解差异：1、对观察者模式的理解观察者模式：一个对象（称为subject）维持一系列依赖于它的对象（称为observer），将有关状态的任何变更自动通知给它们（观察者）。2、对发布/订阅模式的理解发布/订阅模式：基于一个主题/事件通道，希望接收通知的对象（称为subscriber）通过自定义事件订阅主题，被激活事件的对象（称为publisher）通过发布主题事件的方式被通知。3、两种模式之间的差异Observer模式要求观察者必须订阅内容改变的事件，定义了一个一对多的依赖关系；Publish/Subscribe模式使用了一个主题/事件通道，这个通道介于订阅着与发布者之间；观察者模式里面观察者「被迫」执行内容改变事件（subject内容事件）；发布/订阅模式中，订阅着可以自定义事件处理程序；观察者模式两个对象之间有很强的依赖关系；发布/订阅模式两个对象之间的耦合读底。三、举个栗子使用两个栗子形象解释两种模式应用上的差异，让你由内而外，自上而下，感知它的美妙！@佩奇猪的故事1、观察者模式的应用123456789101112131415161718192021222324252627282930313233343536// 以下为半伪代码// 定义下观察者function Observer () &#123; this.update = function()&#123;&#125;&#125;// 定一个下目标function Subscribe () &#123;&#125;// 添加观察者Subscribe.prototype.addObserver = function(observer)&#123;&#125;// 目标通知变更Subscribe.prototype.notify = function()&#123;&#125;// 定义一个佩奇猪的观察者var peikizhuObs = new Observer();peikizhuObs.update = function(what)&#123; console.log("12 o'clock! 佩奇猪想要" + what);&#125;Subscribe.addObserver(peikizhuObs);// 定义一个皮卡丘的观察者var pikachuObs = new Observer();pikachuObs.update = function(what)&#123; console.log("皮卡丘还可以做一点自己比较个性的事情，但是12点我也是要去吃饭的！"); console.log("12 o'clock! 皮卡丘想要" + what);&#125;Subscribe.addObserver(pikachuObs);// 假装12点到了Subscribe.notify('去吃饭啦～'); // 它们都去吃饭了// orSubscribe.notify('继续玩耍～'); // 它们还在一起玩耍说明：可以看出，每一个observer虽然也可以自定义自己的处理程序（update方法），但是观察者模式下，观察者们都是做同一类的事情的。2、发布/订阅模式的应用12345678910111213141516171819202122// 以下为半伪代码// 简易的发布订阅var pubsub = &#123; subscribe: function()&#123;&#125;, publish: function()&#123;&#125;&#125;// 佩奇猪：我要订阅一个「12点」的主题事件，提醒我继续工作pubsub.subscribe("12 o'clock", function(who)&#123; console.log(who + '要继续工作！这就是为什么本猪上了屏幕，而你们上了餐桌。')&#125;);// 皮卡丘：我也要订阅一个「12点」的主题事件，提醒我去吃饭pubsub.subscribe("12 o'clock", function(who)&#123; console.log(who + '要吃饭，去它的工作！')&#125;);// 假装12点到了pubsub.publish("12 o'clock",'PeikiZhu');pubsub.publish("12 o'clock",'PiKaChu');说明：如你所见，发布/订阅模式，订阅的是订阅者各自不同逻辑的处理程序，类比下jQuery订阅点击事件。四、从实现方式上理解差异那么，到了这里，有没有比较有feel了？有没有get到那个…只可意会不可言传的点？还是没有？？？原谅在下不善言辞，只想丢段代码给你。从实现方式上看两者的不同1、实现观察者模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/** * 观察者模式组件 * @author wilton */define(function(require, exports, module) &#123; function ObserverList () &#123; this.observerLists = []; &#125; // 添加观察者对象 ObserverList.prototype.add = function(obj)&#123; // 保证observer的唯一性 if (this.observerLists.indexOf(obj) != -1) return this.observerLists; return this.observerLists.push(obj); &#125;, // 清空观察者对象 ObserverList.prototype.empty = function()&#123; this.observerLists = []; &#125;, // 计算当前的观察者数量 ObserverList.prototype.count = function()&#123; return this.observerLists.length; &#125;, // 取出对应编号的观察者对象 ObserverList.prototype.get = function(index)&#123; if (index &gt; -1 &amp;&amp; index &lt; this.observerLists.length) &#123; return this.observerLists[index]; &#125; &#125;, // 指定位置上插入观察者对象 ObserverList.prototype.insert = function(obj,index)&#123; var pointer = -1; if (index === 0) &#123; this.observerLists.unshift(obj); pointer = index; &#125; else if (index === this.observerLists.length) &#123; this.observerLists.push(obj); pointer = index; &#125; else &#123; this.observerLists.splice(index, 0, obj); pointer = index; &#125; return pointer; &#125;, // 查找观察者对象所在的位置编号 ObserverList.prototype.indexOf = function(obj, startIndex)&#123; var i = startIndex || 0, pointer = -1; while (i &lt; this.observerLists.length) &#123; if (this.observerLists[i] === obj) &#123; pointer = i; break; &#125; i++; &#125; return pointer; &#125;, // 移除指定编号的观察者 ObserverList.prototype.removeIndexAt = function(index)&#123; var temp = null; if (index === 0) &#123; temp = this.observerLists.shift(); &#125; else if (index === this.observerLists.length) &#123; temp = this.observerLists.pop(); &#125; else &#123; temp = this.observerLists.splice(index, 1)[0]; &#125; return temp; &#125; // 定义目标类 function Subject()&#123; this.observers = new ObserverList(); &#125; // 添加观察者 Subject.prototype.addObserver = function(observer)&#123; this.observers.add(observer); &#125; // 移除观察者 Subject.prototype.removeObserver = function(observer)&#123; this.observers.removeIndexAt(this.observers.indexOf(observer, 0)); &#125; // 通知观察者 Subject.prototype.notify = function(params)&#123; var observersCount = this.observers.count(); for(var i = 0; i &lt; observersCount; i++)&#123; this.observers.get(i).update(params); &#125; &#125; function Observer()&#123; // 定义观察者内容更新事件 this.update = function()&#123;&#125; &#125; module.exports = &#123; Observer: Observer, Subject: Subject, // 对象扩展 extend: function(obj, extension)&#123; for (var key in obj) &#123; extension[key] = obj[key]; &#125; &#125; &#125;; &#125;);github-ObserverPattern2、实现发布/订阅模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 发布/订阅模式组件 * @author wilton */// 定义发布/订阅类class Pubsub &#123; constructor () &#123; this.topics = &#123;&#125;; this.subUid = -1; &#125; // 发布事件 publish (topic, args) &#123; if (!this.topics[topic]) return false; let subscribers = this.topics[topic]; let len = subscribers ? subscribers.length : 0; while (len--) &#123; subscribers[len].func(topic, args); &#125; return this; &#125; // 订阅事件 subscribe (topic,func) &#123; if (!this.topics[topic]) this.topics[topic] = []; let token = (++this.subUid).toString(); this.topics[topic].push(&#123; token: token, func: func &#125;) return token; &#125; // 取消订阅 unsubscribe (token) &#123; for (let m in topics) &#123; if (topics[m]) &#123; for (let i = 0; i &lt; topics[m].length; i++) &#123; if (topics[m][i].token == token) &#123; topics[m].splice(i, 1); return token; &#125; &#125; &#125; &#125; return this; &#125;&#125;export default Pubsub;github-PubsubPattern五、结语以上观点只是个人结合实践产出的理解，欢迎各位过路的大佬补充斧正～]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http 文件缓存机制]]></title>
    <url>%2F2018%2F05%2F07%2Fhttp-%E6%96%87%E4%BB%B6%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[强缓存与协商缓存1）浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。在network中，能抓到请求的情况，强制缓存的状态码是 status:灰色的200. size : from memory cache图1：缓存请求图2：状态码灰色两百，不一定是读取缓存2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回304，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源强缓存图3：强缓存expires浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。图4：expire缓存过程cache-ControlExpires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在http1.1的时候，提出了一个新的header，就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000，它的缓存原理是：图5：cache-control缓存过程浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。协商缓存当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串首次访问的响应头图6：首次访问的响应头第二次访问的请求头图7：第二次访问的请求头第二次请求响应头图8：第二次请求响应头Last-Modified，If-Modified-Since图9：modifiled 请求过程浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值。服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header。浏览器收到304的响应后，就会从缓存中加载资源。如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。ETag、If-None-Match【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。它们的缓存管理的方式是：图9：modifiled 请求过程浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题：浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值：服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化浏览器收到304的响应后，就会从缓存中加载资源。以下行为可能改变缓存的默认处理方式当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；当f5刷新网页时，跳过强缓存，但是会检查协商缓存；]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解放双手-ps自动切图脚本]]></title>
    <url>%2F2018%2F05%2F07%2F%E8%A7%A3%E6%94%BE%E5%8F%8C%E6%89%8B-ps%E8%87%AA%E5%8A%A8%E5%88%87%E5%9B%BE%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[前言为什么会做这个呢？大概是因为小编我是一个“懒”到不想切图的程序员吧……某一天听说隔壁部门的大佬有这个想法，然后就自己也摆弄一下下。说说ps脚本ps脚本的设计目的，主要是为了辅助设计师们设计的。所有的脚本操作都必须基于一点：你必须得打开photoshop，然后看着它自己进行各种骚操作……所以我在国内的网站搜资料，找到的比较多的是【教设计师如何用脚本简化设计操作】这一类的教程。后来只好去看英文的开发文档photoshop文档（然而小编英文好不……），后来再翻了翻发现一些可以辅助的中文网站，如http://nullice.com/archives/1790#捋捋实现思路小编在网上看到一个例子，它的实现思路如下：小编认为，频繁的新建／删除文件的操作是不必要的。但如果不新建文件操作，直接修改原psd的画布大小，又有其他图层干扰。所以就优化了一下，下面是小编最终脚本实现思路：想想为什么要处理图层原因有三：其一，小编收到的psd一般比较复杂，有些地方需要做一些处理才能导出；其二，为了减少图层，避免卡机；其三，文件夹无法复制（没有复制的api），图层的话，可见图层可以复制，但不可见的，或者是文字图层、形状图层等非常规图层无法复制写写代码步骤一：首先你的知道导出的图片要存在哪里可以选择写死路径，当然更人性化的就是调个弹窗出来让用户自己选择嘛～12// 保存用户选择的文件夹路径var outputFolder = Folder.selectDialog('请选择输出文件夹');步骤二：处理图层这里可以根据自己的需要去写逻辑，小编的处理逻辑是：【如果组里没有组，就把这个图合并】。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 保存需要合并的组var mergeGroupArr = [];// 保存需要移动的图层var moveLayerArr = [];// 特殊字符var ISBG = 'bg'; // 处理图层dealLayer(app.activeDocument.layerSet); // 处理图层function dealLayer(groups) &#123; // 寻找组中需要合并的组 findNestGroup(app.activeDocument.layerSets, getNeedMergeGroup); // 合并组 mergeGroup(mergeGroupArr); // 寻找组中需要移动的图层 findNestGroup(app.activeDocument.layerSets, getMoveLayer, getMoveLayer); // 移动图层 moveLayer(moveLayerArr); // 删除所有组 app.activeDocument.layerSets.removeAll();&#125; // 查找组中组function findNestGroup(groupsEle, noNestGroupCallback, callback) &#123; if (groupsEle.length &gt; 0) &#123; for (var groupsIndex = 0; groupsIndex &lt; groupsEle.length; groupsIndex++) &#123; // 如果文件夹名包含特定的字符，就直接合并该文件夹 if (judgeIncludeText(ISBG, groupsEle[groupsIndex].name)) &#123; getNeedMergeGroup(groupsEle[groupsIndex]); &#125; else &#123; doFindNestGroup(groupsEle[groupsIndex], findNestGroup, noNestGroupCallback, callback); &#125; &#125; &#125;&#125; // 执行遍历组function doFindNestGroup(groupEle, hasNestGroupCallback, noNestGroupCallback, callback) &#123; // 如果组里有组 if (groupEle.layerSets.length &gt; 0) &#123; !!hasNestGroupCallback &amp;&amp; hasNestGroupCallback instanceof Function ? hasNestGroupCallback(groupEle.layerSets, noNestGroupCallback, callback) : ''; &#125; else &#123; !!noNestGroupCallback &amp;&amp; noNestGroupCallback instanceof Function ? noNestGroupCallback(groupEle) : ''; &#125;!!callback &amp;&amp; callback instanceof Function ? callback(groupEle) : '';&#125; // 获取需要合并的组function getNeedMergeGroup(ele) &#123; mergeGroupArr.push(ele);&#125; // 合并组function mergeGroup(groupArr) &#123; for (var i in groupArr) &#123; groupArr[i].merge(); &#125;&#125;合并完之后，问题来了，因为小编只合并了最小的组，其他组没有合并，也就是说，图层还在组里。在ps的编辑界面里面是有取消编组的按钮操作的，但小编在api里面没发现，所以之后遍历把图层移出组，最后再把所有组删除。123456789101112131415161718192021222324252627282930313233343536373839// 处理图层function dealLayer(groups) &#123; ... // 寻找组中需要移动的图层 findNestGroup(app.activeDocument.layerSets, getMoveLayer, getMoveLayer); // 移动图层 moveLayer(moveLayerArr); // 删除所有组 app.activeDocument.layerSets.removeAll();&#125; // 获取需要移动的图层function getMoveLayer(groupEle) &#123; if (groupEle.layers.length &gt; 0) &#123; for (var layerNum = 0; layerNum &lt; groupEle.layers.length; layerNum++) &#123; // 如果不是组，就把图层移出去 if (groupEle.layers[layerNum].typename !== 'layerSet') &#123; moveLayerArr.push(groupEle.layers[layerNum]); &#125; &#125; &#125;&#125; // 移动图层function moveLayer(layerArr) &#123; for (var i in layerArr) &#123; // 对特殊的图层进行栅格化 // 文字图层 if (layerArr[i].kind == 'LayerKind.TEXT') &#123; layerArr[i].rasterize(RasterizeType.TEXTCONTENTS); layerArr[i].name = 'text' + i; &#125; // 形状图层 if (layerArr[i].kind == 'LayerKind.SOLIDFILL') &#123; layerArr[i].rasterize(RasterizeType.FILLCONTENT); &#125; layerArr[i].move(app.activeDocument.layers[0], ElementPlacement.PLACEBEFORE); &#125;&#125;步骤三：导出图片剩下这步主要就是ps脚本的api的运用。大家可以看下面的代码，都有详细的注释12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 当前文档所有图层var layers = app.activeDocument.layers;// 当前文档var doc = app.activeDocument;// 创建新文档，尺寸为内存的图层大小app.documents.add(doc.width, doc.height, 72, 'myDocument', NewDocumentMode.RGB, DocumentFill.TRANSPARENT);// 遍历所有图层for (var i = 0; i &lt; layers.length; i++) &#123; // 将target重置到设计稿文档 app.activeDocument = doc; // 保存图层名称 var layerName = layers[i].name; // 将图层拷贝到内存 layers[i].copy(); // 获取图层大小 var bounds = layers[i].bounds; // 宽度 var width = bounds[2] - bounds[0]; // 高度 var height = bounds[3] - bounds[1]; // 判断是否超出宽高度 var realWidth = width &gt; doc.width ? doc.width : width; var realHeight = height &gt; doc.height ? doc.height : height; // 将target重置到输出文档 app.activeDocument = app.documents[1]; // 重置图片大小 app.activeDocument.resizeCanvas(realWidth, realHeight, AnchorPosition.MIDDLECENTER); // 创建新图层 app.activeDocument.artLayers.add(); // 将内存中的图层拷贝到新文档 app.activeDocument.paste(); // 获取图片格式配置 var photoType = judgeIncludeText(ISBG, layerName) ? getJPEGFormat() : getPNGFormat(); // 图片输出路径及文件名 var file = new File(outputFolder + '/' + layerName + '.' + photoType.type); // 导出文件 app.activeDocument.exportDocument(file, ExportType.SAVEFORWEB, photoType.format); // 将Photoshop的当前图层从图层列表中删除。 app.activeDocument.activeLayer.remove();&#125;// 关闭新文档（不存储）app.activeDocument.close(SaveOptions.DONOTSAVECHANGES); // 获取PNG图片格式配置function getPNGFormat() &#123; // 相当于【储存为web格式】 var option = new ExportOptionsSaveForWeb(); // 支持透明度 option.transparency = true; // 色彩范围 option.colors = 256; // 格式 option.format = SaveDocumentType.PNG; // 不用png8格式压缩 option.PNG8 = false; // 质量 option.quality = 80; return &#123; format: option, type: 'png' &#125;;&#125;// 获取jpeg图片格式配置function getJPEGFormat() &#123; var option = new ExportOptionsSaveForWeb(); // 色彩范围 option.colors = 256; // 格式 option.format = SaveDocumentType.JPEG; // 质量 option.quality = 75; return &#123; format: option, type: 'jpeg' &#125;;&#125;想想问题1、这个小工具固然是方便的，但是却很以来psd的质量。所以如果要投入生产的话需要美术大大的配合，且开发人员也需在跑脚本前检查一遍。不过相对于手动切图，检查的时间还是非常少的。2、这版本的小工具其实还有很多地方可以改进，比如说没有对图层的命名做处理，没有对同名图片覆盖的情况做处理等。]]></content>
      <categories>
        <category>资源工具</category>
      </categories>
      <tags>
        <tag>工具开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oocss到ooscss的进化]]></title>
    <url>%2F2018%2F05%2F05%2Foocss%E5%88%B0ooscss%E7%9A%84%E8%BF%9B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[之前写css的时候一直都觉得少了点什么，刚好这几天迭代自己写的一个内部项目的时候，发现Vue组件中的sass代码写的比较乱，维护不方便所以顺手重构一下。于是接触到了oocss和ooscss。在阅读大漠关于oocss、ooscss的文章之后，整理了一下他文中提到的方法。有时间的话还是推荐看一下原文，最好是英文原文，个人理解难免会有些偏差，而且作者的蜜汁直译让某些点不太好理解。https://gist.github.com/blackfalcon/5255648css优化的三大目标代码复用。主要是节省流量，像淘宝首页这种日pv在1亿左右的页面，假设css文件每节省下1kb，光首页一个页面一年就能减少33TB的流量费用，按市价0.8/GB算也就是27000块RMB流量费。可维护性。这个就不用多说了，改过css祖宗代码的手微微颤抖。可扩展性。比如说我有个按钮，如果我想给它加个圆角效果1234567891011121314151617181920.btn&#123; width:100px; height:100px;&#125;方案一：直接改btn类源码.btn&#123; width:100px; height:100px; border-radius:10px;&#125;但面向对象的开放-封闭原则告诉我，改动类源码的扩展不是好扩展。方案二：不改btn源码,多写一个类，并把类名加到Dom上。在OOCSS中，扩展功能的方式就是这种。.btn&#123; width:100px; height:100px;&#125;.rounded&#123; border-radius:10px;&#125;解决方案：上面三点怎么看怎么像面向对象编程的问题，老前辈们也是这么想的，于是2008年oocss应运而生。oocss——撸纯css时代的解决办法思路强调代码复用布局和样式分离内容和容器分离实例：大名鼎鼎的bootstrap就是oocss的最好体现通过视觉类名（名字看得出来样式那种）实现代码复用，减少冗余。123456789101112.img-rounded &#123; -webkit-border-radius: 6px; -moz-border-radius: 6px; border-radius: 6px;&#125;.img-circle &#123; -webkit-border-radius: 500px; -moz-border-radius: 500px; border-radius: 500px;&#125;使用网格布局系统，实现布局和样式的分离，不用到处写很相似的布局代码。而且布局代码分离出来还有一个好处，能顺便把布局兼容或者宽度适配问题集中处理。12345678910111213.col-1 &#123; -webkit-box-flex: 0; -ms-flex: 0 0 8.333333%; flex: 0 0 8.333333%; max-width: 8.333333%;&#125;.col-2 &#123; -webkit-box-flex: 0; -ms-flex: 0 0 16.666667%; flex: 0 0 16.666667%; max-width: 16.666667%;&#125;至于内容和容器分解，这里作者举的例子让我觉得不是很理解，但这不要紧，重点是后面的ooscss。123456789 &lt;div class=&quot;post&quot;&gt; &lt;p class=”metadata”&gt; &lt;a&gt;Author name&lt;/a&gt;commented on&lt;a&gt;21-02-2010&lt;/a&gt;@ &lt;/p&gt;&lt;/div&gt;//内容与容器没有分离 &lt;p class=”metadata postMetaData”&gt; &lt;a&gt;Author name&lt;/a&gt;commented on&lt;a&gt;21-02-2010&lt;/a&gt;@&lt;/p&gt;//内容与容器分离oocss的缺点：直接上代码。由于通过类名来实现代码复用，一个元素上6、7各类名是家常便饭，相信接触过bootstrap的同学都有这种感受。123&lt;fieldset&gt; &lt;label for=&quot;field&quot; class=&quot;arial-font-family larger-font-size text-color mbm&quot;&gt;Form Label&lt;/label&gt; &lt;/fieldset&gt;ooscss——预处理时代的新思路（需要sass基础）原文1234561.There is no CSS, only Sass//吐槽，忽略2.Placeholder presentational objects3.Mixins for reusable logic to create repetitive CSS4.Semantic classes in the DOM, placeholder presentational objects in your Sass5.Build UI structures and frameworks otherwise impossible with CSS//又是吐槽，忽略6.Extend classes in your Sass, not the DOM%placeholder占位符声明视觉类名,在语义化类名中继承实现复用。==添加到DOM上的是语义化类名，这是与bootstrap最大的区别。==12345678910111213141516171819202122//视觉类名：看名字就知道是什么样式那种//语义化类名：看名字就知道这个块是提供什么信息或者功能那种%text-gray&#123; color: rgb(161, 161, 161); font-size: 2rem;&#125;summary-version&#123; @extend %text-gray;&#125;summary-date&#123; @extend %text-gray;&#125;summary-name&#123; @extend %text-blue;&#125;//这里要注意，视觉类名不直接加到元素类名上，而是通过语义化类名继承，再讲语义化类名加到DOM元素上。这是与oocss最大的不同。编译出来的代码如下：summary-version,summary-date,summary-name,text-gray&#123; color: rgb(161, 161, 161); font-size: 2rem;&#125;//其实还是通过类名复用，只不过将类名从DOM元素转移到选择器上而已。用mixin创建可重复的css。这里对生成的css代码复用没有贡献，是对sass源码的复用。提高开发效率和可维护性。12345678910111213@mixin alert-variant($background, $border, $color) &#123; color: $color; @include gradient-bg($background); border-color: $border; hr &#123; border-top-color: darken($border, 5%); &#125; .alert-link &#123; color: darken($color, 10%); &#125;&#125;在sass中对类进行扩展，而不是在DOM中（像bootstrap）。123456789// 比如我想给简介的游戏名添加灰色背景%bg-gray&#123; background:#ccc;&#125;summary-name&#123; @extend %text-blue; @extend %bg-gray;&#125;//在sass中扩展，不需要给元素添加更多类名]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写给前端的后端能力一--我的第一个WEB服务与二级域解析]]></title>
    <url>%2F2018%2F05%2F04%2F%E5%86%99%E7%BB%99%E5%89%8D%E7%AB%AF%E7%9A%84%E5%90%8E%E7%AB%AF%E8%83%BD%E5%8A%9B%E4%B8%80-%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAWEB%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%8C%E7%BA%A7%E5%9F%9F%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一、前言得益于互联网的飞速发展，前后端分工越来越明确。随着nodejs的盛行，后端开发技术对于做前端的小伙伴们也越来越得要领。接下来的一系列文章，主要对常见的应用场景进行剖析，辅助前端扫盲，同时完善后端的能力；二、能力模型要求1、Linux基础：控制操作系统的基本能力；辅助学习资料2、Nginx基础：端口转发，还有下一章节会讲到的https；辅助学习资料3、Nodejs基础：前端的服务器端编程能力；辅助学习资料三、开始搭建掌握了以上3门能力基础，恭喜你你已经具备了服务器开发的基础能力。接下来就可以开始捣鼓了。我们定的第一个目标：完成一个web服务搭建，并对外解析到某个二级域；步骤1、服务器和域名的购买我这里选用了阿里云作为我的服务提供商，阿里提供了一整套的服务。阿里的云服务器默认有云盾做守护，一些进程的异常操作或WEB文件漏洞会被及时扫描出来然后发短信到拥有者，这点服务真的做得非常棒。域名的购买就不需要细谈；步骤2、添加域名解析其中，几个关键信息如下，即可完成配置。（1）记录类型一般选择A；（2）主机记录因为是新增二级域，我这里填写了webhook；（3）记录值为你的服务器IP；步骤3、搭建web服务这里推荐使用Express应用生成器，基于nodejs，可以很快在服务器端搭建起一个http服务，端口启动在8899，通过pm2做进程守护；（1）为什么要使用Express？Express是目前最流行的基于Node.js的Web开发框架，可以快速地搭建一个完整功能的网站。Express上手非常简单，非常适用于初学者，这里贴出生成器教程，可自行进入搭建；Express 应用程序生成器教程：http://expressjs.com/zh-cn/starter/generator.html（2）为什么要使用pm2？我们知道每次node程序代码修改需要重启服务器才能生效，PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。pm2这里最常用的3个指令：123pm2 start app.js --watch：以监听变更的形式启动apppm2 status：查看当前所有启动应用的状态pm2 logs：动态输出程序日志因为使用简单，这里不再描述；PM2：http://pm2.keymetrics.io/docs/usage/quick-start/步骤4、端口检查分2步走，（1）查看应用端口1netstat -nltp（2）ping下端口内网访问是否成功：1echo '' |telnet 127.0.0.1 8899如果结果符合预期，说明web服务现在是可以正常启动的。不过还是无法通过ip+端口进行访问，这个时候就需要nginx作为转发了，以下会讲到；步骤5、添加安全组规则阿里云服务器端口很多端口默认是不开放的，需要在后台进行开发。操作步骤如下：阿里云后台 云服务器，管理面板，网络与安全的安全组，配置规则，添加安全组规则；（1）端口范围：8899/8899（2）授权对象：0.0.0.0/0步骤6、利用nginx做转发，（1）nginx的安装，这里不做讲解；（2）编辑ng配置：1vi /usr/local/nginx/conf/nginx.conf添加以下配置：123456789101112server&#123; listen 80; server_name webhook.37oceanteam.com; location / &#123; proxy_pass http://127.0.0.1:8899; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125;（3）判断nginx配置文件是否正确：1/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf正确的话结果会是success，接着就可以重启了。（4）平滑重启：4.1 查询主进程号：1ps -ef|grep nginx4.2 平滑重启：1kill -HUP Nginx主进程号步骤7、浏览器访问不出意外，我们的搭建流程应该都走完了。接着直接在浏览器访问webhook.37oceanteam.com，便可以看到我们的web服务了。四、结尾以上流程是对我们第一阶段的挑战，希望通过讲解，让大家可以认识到搭建这样一个服务的所需要的知识储备，并作为后端第一层能力的突破。下一节，我们将讲解如何配合nginx搭建一个HTTPS服务，敬请期待。。。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>服务端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS学习]]></title>
    <url>%2F2018%2F05%2F04%2FHTTPS%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言虽然之前有了解HTTPS，但是概念模糊并没有对其运行机制有所理解，综合各方面资料，现在以自问自答的方式对HTTPS的脉络做个梳理。有错误的地方，欢迎评论中指出。为什么会有HTTPS？因为HTTP通信不安全， “中间人”可以轻易获取和篡改HTTP通信的内容。“中间人”是什么，它是怎么获取和篡改http通信内容的？开发人员用手机绑定PC机上的代理工具(fiddler，Charles)，访问测试环境中的页面时，代理工具就是一个典型的中间人。主体是手机和测试机页面进行交互访问。可是所有请求的情况，都被PC开发机抓包了。也就是任何网络提供者，大到联通电信运营商，小到一个免费WiFi，以及提供网络代理服务的PC机，都是”中间人”，理论上只要他们愿意，就可以对HTTP通信进行监控和篡改。在这种”中间人”的监控下，HTTP通信几乎是裸体的：为什么对称加密不可靠？既然HTTP通信这么容易被监听，那客户端和服务器通信进行加密不就好了，协商一个秘钥，服务器加密发给客户端，客户端解密获取内容。问题是，”秘钥”本身如何安全传递给通信双方，如果中间人截取了秘钥，通信的加密仍旧形同虚设，如何保证秘钥的安全传递呢？非对称加密为什么也不牢靠？对称加密不可靠，就用非对称加密好了。服务器私钥加密内容，然后传递公钥给客户端。客户端用公钥解密通信内容，进行通信。在这个过程中。中间人即使截获了服务器公钥，因为没有私钥也无法对客户端用公钥加密的内容进行解密获取。可是，”公钥”本身也是可以被伪造的，如果客户端收到的公钥不是服务器的，而是”中间人”的，整个非对称加密仍旧形同虚设。客户端如何确保自己收到的公钥就是服务器的呢？证书为什么也不安全？客户端为了确保自己收到的公钥确实来自要访问的服务器，要求服务器传递一个证书，证书将公钥和服务器信息绑定，以证明公钥并非来自中间人。这里的证书就是公钥的”身份证”，用来确认公钥身份。问题是，证书也是可以被伪造的，中间人伪造一个假证书传递给客户端怎么办？数字签名为什么也不保险？对服务器认证的CA，会把服务器信息hash一下，然后用自己的私钥对hash摘要加密，加密结果放到证书上。客户端从认证CA那里得到公钥，就可以验证证书的有效性，最终确认web站点公钥的有效性。可是，问题又绕回去了，客户端怎么确保自己收到的公钥是对服务器认证的CA的，而不是中间人的呢？所以CA 的公钥 也要证书来认证，于是CA的上层还有更高级的CA，更高级的CA会认证当前CA，那更高级的CA 谁来认证呢？根证书存在一个顶级CA，来对其他CA认证，它的根证书内置在用户操作系统中被直接信任。根证书会对二级CA的证书进行认证，二级CA的证书又会对下级CA或者web站点进行认证。HTTPS通过一级级的CA逐级认证的证书链的形式确保了通信安全，可是为什么证书链这么麻烦，直接让顶级CA 对web站点认证不就好了？为什么要搞证书链？一般站点的认证签名工作是在线进行的，并且要用到私钥，让顶级CA直接面对数量庞大的用户，处在连线状态的CA被攻击的风险就非常高。一旦顶级CA被攻击甚至私钥被窃取，内置在用户操作系统中的根证书也就是失去了认证效力。所以顶级CA不会对站点服务器直接进行认证签名(据说其私钥被离线保存在金库中，只是被定期拿出来确保相关密码设备的正常工作，签署证书吊销列表，以及签署新的二级证书)，而是由其下级CA进行，然后通过证书链对最终的站点服务器进行认证。有了证书链，各级CA逐级认证，只要不是顶级CA，任何一级CA被攻破，都不妨碍整个证书体系继续发挥验证的作用。总结这里只是对HTTPS中常见的各种概念的一个梳理和串联，当中还有不少细节并么有完全澄清，不过在这些HTTPS通信中常见的概念有了合理解释后，对以后深入准确的理解HTTPS应该会更有帮助。参考资料https://github.com/huoteng/blog/issues/1]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何构建一个 React App ?]]></title>
    <url>%2F2018%2F02%2F06%2F%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA-React-App%2F</url>
    <content type="text"><![CDATA[一、前言想要构建一个 React App ，第一步你要完成Reactjs学习计划表。二、需求在本地搭建react开发环境，并构建简单的todolist项目，内容包含但不限于以下内容，界面自行设计：添加 todo ；删除 todo ；修改 todo ；使用localstorage做todo数据存储。三、准备来到这一步，相信你已经完成基本学习了，那么我们把脚手架工具 create-react-app 搭起来：全局安装脚手架工具1npm install -g create-react-app创建一个app1create-react-app myapp进入开发目录1cd myapp安装依赖1npm installpackage.json 文件12345678910111213141516&#123; "name": "myapp", "version": "0.1.0", "private": true, "dependencies": &#123; "react": "^16.2.0", "react-dom": "^16.2.0", "react-scripts": "1.0.17" &#125;, "scripts": &#123; "start": "react-scripts start", // 以开发环境跑起项目 "build": "react-scripts build", // 构建打包项目到生产目录 "test": "react-scripts test --env=jsdom", // 以测试模式启动项目 "eject": "react-scripts eject" // 输出完整包括 Webpack 配置的项目目录（不可逆操作） &#125;&#125;启动项目1npm start四、这么来设计我们的 React 目录结构初始目录：myapp├─ .DS_Store├─ .gitignore├─ README.md├─ package.json├─ public│ ├─ favicon.ico│ ├─ index.html│ └─ manifest.json└─ src├─ App.css├─ App.js├─ App.test.js├─ index.css├─ index.js├─ logo.svg└─ registerServiceWorker.js设计后目录：my-app├─ .gitignore├─ README.md├─ package.json├─ public│ ├─ favicon.ico│ ├─ index.html│ └─ manifest.json└─ src├─ App.css├─ App.js├─ App.test.js├─ actionCreators│ └─ index.js├─ bootstrap.min.css├─ components│ ├─ List.js│ ├─ Nav.js│ ├─ btn│ └─ popup├─ configs│ ├─ actionTypes.js│ └─ index.js├─ index.css├─ index.js├─ logo.svg├─ reducers│ └─ index.js├─ registerServiceWorker.js├─ store│ └─ index.js└─ utils├─ index.js└─ localcache.js设计后的 package.json :1234567891011121314151617181920212223&#123; "name": "my-app", "version": "0.1.0", "private": true, "dependencies": &#123; "immutable": "^3.8.2", "react": "^16.2.0", "react-dom": "^16.2.0", "react-redux": "^5.0.6", "react-scripts": "1.0.17", "redux": "^3.7.2", "redux-thunk": "^2.2.0" &#125;, "scripts": &#123; "start": "react-scripts start", "build": "react-scripts build", "test": "react-scripts test --env=jsdom", "eject": "react-scripts eject" &#125;, "devDependencies": &#123; "redux-devtools": "^3.4.1" &#125;&#125;设计简析：新增了 utils ：操作 localStorage 的增（ create ）、查（ retrieve ）、改（ update ）、删（ delete ）、撤销删除（ recover ）、完成（ done ）；新增了 configs ：配置 action type 的名称；新增了 components ：组件；新增了 actionCreators ：设置 action 的 type 和 payload ；新增了 reducers ：将 reducers 进行拆分操作，再合并暴露给外部；新增了 store.js ：新建 store 并注入中间件；五、利用 Redux 解决组件间通信问题Provider通过 react-redux 引入高阶组件 Provider ，用 Provider 包裹根组件，将 store 注入到所有子组件，如此一来组件间的通信问题就得以解决了：123&lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt;&lt;/Provider&gt;connect但是这么做有个问题：每一个组件需要的 store 不相同，注入全部并不优雅，此时我们引入了 connect ，动态地输出组件需要的（最小）属性：1234567891011// 将从 store 得到 state 按需映射成 props 传入组件，对应的 actions 也做同样的处理；这就是 connect 的作用：作用：连接 React 组件与 Redux storeconnect([mapStateToProps], [mapDispatchToProps], [mergeProps],[options]) // connet 连接 React 组件与 Redux storeexport default connect(state =&gt; &#123; return &#123; dialogStatus: state.ui.get('dialogStatus') &#125;&#125;, &#123; modifyDialog&#125;)(List);六、利用 React-Router 处理路由问题BrowserRouter包裹着根组件，对路由整体做配置；Switch根据子组件 Route 对路由进行切换，按照子组件上不同的属性应用不同的规则，显示不用的页面；可以包含的其他子组件还有 Redirect ；Route主要用到以下几个属性：path ：路由匹配的路径；render ：渲染的内容；exact ：严格匹配当前的 path ；七、总结本篇主要偏向实际应用，对于各项框架的 API 的使用和原理不作详细的描述；附上 demo ： react-work.zip 。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当我们谈论React时，我们谈论些什么？]]></title>
    <url>%2F2018%2F01%2F09%2F%E5%BD%93%E6%88%91%E4%BB%AC%E8%B0%88%E8%AE%BAReact%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E8%B0%88%E8%AE%BA%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前言当我们谈论react，我们会谈论些什么？或许你没用过react，但是你应该或多或少听过一些关于react的名词：虚拟DOM，differ算法，生命周期等。这些名词究竟是什么意思，看完本文，希望你会有答案。 一、react 是什么？React是一个构造可组合式用户界面的库。它鼓励创建可重用的UI组件显示会随着时间而改变的数据。二、react设计的特点?1、组件化的思想，将UI上功能相对独立的模块定义成组件，将小的组件通过组合或嵌套构造成大的组件，完成整体UI的构建，这意味着组件是高度可重用的。2、虚拟DOM和数据单向绑定机制决定了react的响应很快。3、并非一个完整的MVVM框架，它是一个纯V层框架，需要数据流的支撑（例如Redux）处理行为对应的响应。三、react为什么响应快？假如现在你需要写一个像下面一样的表格的应用程序，这个表格可以根据不同的字段进行升序或者降序的展示图3-1：例子我们主要从状态维护和视图更新去看看MVC模式和MVVM模式实现的思路：MVC: 给表格头部加点击事件，用户的点击特定的表头，对比表格里面的内容进行排序,然后用 JS 或者 jQuery 操作 DOM，更新页面的排序状态（表头的那几个箭头表示当前排序状态，也需要更新）和表格内容。随着表格越来越复杂，需要进行监听的事件及更新dom的操作越来越多，代码难以维护。MVVM: 模版中声明视图组件是和什么状态进行绑定的，双向绑定引擎就会在状态更新的时候自动更新视图，大大降低维护状态 -&gt; 视图的复杂程度。一旦状态发生了变化，就用模版引擎重新渲染整个视图，然后用新的视图更换掉旧的视，但是这样一来，即使一个小小的状态变更都要重新构造整棵 DOM，性价比太低，对于大型视图来说，更是不可取。React: 在维护状态这方面上，react也是mvvm的做法，但是在更新视图层上，react另辟蹊径，使用了Virtual DOM，加了一些特别的步骤来避免了整棵 DOM 树变更。虚拟DOM算法是React性能优于其它框架的关键因素，那么什么是虚拟DOM? 怎么用虚拟Dom算法实现Dom树的更新？我们有必要从React的生命周期聊起。四、react的状态更新 4.1 何时触发组件状态更新？和vue类似的，React组件的生命周期分成三个状态： Mounting，Updating和Unmounting。Mounting：组件被render解析生成对于DOM节点并插入浏览器DOM结构的过程Updating：一个已经mouted的组件被重新render的过程。Unmounting：一个已经mouted的组件被从DOM结构中移除的过程。每个状态，React都封装了对应的钩子函数，如下图：图4-1：组件生命周期钩子函数我们关心组件状态的更新过程，发生在Updating这个过程。如上，当state和props发生变化时，会来到图中的函数①接受到变化，函数②会判断组件是否需要更新（如图红色方框）：组件不需要更新：函数②返回false，终止掉Updating的过程，组件需要更新：函数②返回true，继续触发钩子函数③，进行重新render()，更新视图。在这个过程，react是如何判读组件是否需要更新的？下面将隆重请出我们的Virtual DOM算法出场。4.2 为什么使用Virtual DOM事实上，DOM是很慢的，如果我们把一个简单元素DIV的属性都打印出来，可以看到有这么多东西：图4-2：Dom元素属性信息这一坨密密麻麻的属性说明了什么？说明了，DOM 元素非常庞大。这意味着，当一个页面的Dom结构比较复杂的时候，操作它们的时候你要小心翼翼，轻微的触碰可能就会导致页面重排，这可是杀死性能的罪魁祸首。相对于 DOM 对象，原生的 JavaScript 对象处理起来更快，而且更简单。DOM 树上的结构、属性信息我们都可以很容易地用 JavaScript 对象表示出来。以下代码片段是用Javascript对象表示一个列表的属性及节点的信息：1234567891011var element = &#123; tagName: 'ul', // 节点标签名 props: &#123; // DOM的属性，用一个对象存储键值对 id: 'list' &#125;, children: [ // 该节点的子节点 &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: ["Item 1"]&#125;, &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: ["Item 2"]&#125;, &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: ["Item 3"]&#125;, ]&#125;Virtual DOM 算法的原理主要包括以下步骤：1. 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中。 2. 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异。 3. 把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了。 本质就是，在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存。既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM），如图：图4-2：虚拟Dom的作用上面说的步骤一与步骤三不难理解，问题是Virtual DOM如何对比新的树和旧的树的差异呢？这是Virtual DOM最核心的部分—differ算法。4.3 differ算法前面我们说过，React的应用是由众多组件组合或嵌套构建起来的完整的树。所以，比较要比较新树和旧树的差异，就可以从三个层面来比较：树之间的差异：Tree differ组件之间的差异：Component diff组件内的差异：Element diff4.3.1 Tree differ计算一棵树形结构转换成另一棵树形结构的最少操作，是一个复杂且值得研究的问题.传统 diff 算法通过循环递归对节点进行依次对比,算法复杂度达到 O(n^3),其中 n 是树中节点的总数。O(n^3) 到底有多可怕，这意味着如果要展示1000个节点，就要依次执行上十亿次的比较。这种指数型的性能消耗对于前端渲染场景来说代价太高了！ CPU 每秒钟能执行大约30亿条指令，即便是最高效的实现，也不可能在一秒内计算出差异情况。由于Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计，所以React制定大胆的策略：干脆忽略跨层级的比较，两棵树只会对同一层次的节点进行比较。如下图：图4-3：只对比同级的差异只会对相同颜色方框内的 DOM 节点进行比较。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。但是如果出现了 DOM 节点跨层级的移动操作，如下图，A节点（第二层）被移动了D节点下面（第三层）React diff 会有怎样的表现呢？图4-3：跨层级差异当根节点发现子节点中 A 消失了，就会直接销毁 A；当 D 发现多了一个子节点 A，则会创建新的 A（包括子节点）作为其子节点。此时，React diff 的执行情况：create A -&gt; create B -&gt; create C -&gt; delete A由此可发现：当出现节点跨层级移动时，并不会出现想象中的移动操作，而是以 A 为根节点的树被整个重新创建，这是一种影响 React 性能的操作，因此 React 官方建议不要进行 DOM 节点跨层级的操作。注意：在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，可以通过 CSS 隐藏或显示节点，而不是真的移除或添加 DOM 节点。4.3.2 Component diffReact 对于组件间的比较所采取的策略如下：如果是相同组件，进一步比较** 组件内的元素**是否发生变化（Element diff）。 如果不是相同组件，则将该组件判断为 dirty component，从而** 替换整个组件下的所有子节点** 。 如图，左边树的D组件换成了右边新树的G组件，React直接替换掉D组件的所有节点。图4-3：不同组件的差异策略4.2.2.2 Element diff当节点处于同一层级时，React diff 提供了三种节点操作：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。 插入与删除很好理解，如下图，老集合中包含节点：A、B、C、D，更新后的新集合中包含节点：B、A、D、C。图4-2：插入和删除此时新老集合进行 diff 差异化对比，发现 B != A，则创建并插入 B 至新集合，删除老集合 A；以此类推，创建并插入 A、D 和 C，删除 B、C 和 D。React 发现这类操作繁琐冗余，因为这些都是相同的节点，但由于位置发生变化，导致需要进行繁杂低效的删除、创建操作，其实只要对这些节点进行位置移动即可。针对这一现象，React 提出优化策略：对同一层级的同组子节点，添加唯一 key 进行区分。 新老集合所包含的节点，如下图所示，新老集合进行 diff 差异化对比，通过 key 发现新老集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将老集合中节点的位置进行移动，更新为新集合中节点的位置，此时 React 给出的 diff 结果为：B、D 不做任何操作，A、C 进行移动操作，即可。新老集合所包含的节点，如下图所示，新老集合进行 diff 差异化对比，通过 key 发现新老集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将老集合中节点的位置进行移动，更新为新集合中节点的位置，此时 React 给出的 diff 结果为：B、D 不做任何操作，A、C 进行移动操作，即可。图4-2：移动操作 总结以上，就是关于React虚拟Dom及Differ算法的简单介绍。总而言之， 虚拟Dom的原理就是先用JavaScript表示Dom结构（实际中是使用React提供的语法糖JSX来写），构建出一颗真正的Dom树插入文档中。当Dom树发生变化时，React会重新构造一个新的虚拟树，将新树和旧树做对比，有差异则重新渲染视图。好了，通过这么一番介绍，你是否对一些关于React的名词有了进一步的认识呢？]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[37海外前端Blog规范]]></title>
    <url>%2F2017%2F12%2F21%2Flog-Test%2F</url>
    <content type="text"><![CDATA[一、如何归属文章文章的分类一般有两个维度：分类和标签。一般而言，分类项由博客委员会成员确立，各成员发表的博客都应该归类于此。目前包含的分类有：前端开发服务端开发资源工具开发规范团队生活如需新增分类项，需博客委员会审核通过。标签则是对当前博文所包含属性的一种标记，如JavaScript、https等标签，由博主根据博文情况自行标记。二、如何使用标题《37海外前端Blog规范》（以下简称为《规范》）中要求，每一篇博文中最多不超过两级标题，两级标题以下的内容，使用加粗的方式进行强调。1. 一级标题的使用一级标题作为博文中最高级别的标题，由4个“#”符号生成。2. 二级标题的使用二级标题作为博文中的最低级别的标题，由5个“#”符号生成。三、如何使用强调和突出强调和突出主要表现在文字的正斜体，文字颜色和粗细三方面。《规范》规定，博文中文字部分的强调突出限定于以下三种方式：使用2个“*”或“_”符号加粗使用红色（color=red）使用1个“_”符号倾斜说明：在博文的实际书写过程，可以将以上三种方式任意结合，达成不同的强调效果。四、如何使用代码JavaScript:1var name = "wilton"; // 这是javascript的代码，支持语法高亮的哦HTML:12&lt;!-- html代码也可以语法高亮的哦 --&gt;&lt;div class="box" id="J_box"&gt;这是测试的html标签&lt;/div&gt;CSS:12345/* css代码也可以高亮的哦 */.box&#123; display: -webkit-flex; display: flex;&#125;五、如何使用图片图片的使用包含两个像素：图像和图像说明。《规范》要求图像和图像文字说明均居中显示，文字字号使用3字号，色号使用“#777”，说明格式为：图[一级标题所在编号]-[该级标题下图片编号]:[具体说明]。如 图5-1:念慈小姐姐哦图5-1：念慈小姐姐哦六、博文发表流程团队成员在博文发表过程需要经过一下流程：博主新建博文开发分支博主依据相关规范书写博文并做本地调试提交博客委员会审核审核通过则执行下一步，否则返回第二步合并博文源码并发布博文具体流程图如下：图6-1：博文发表流程图附录：Markdown语法参考]]></content>
      <categories>
        <category>开发规范</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new "My New Post"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment]]></content>
  </entry>
</search>
