<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何构建一个 React App ?]]></title>
    <url>%2F2018%2F02%2F06%2F%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA-React-App%2F</url>
    <content type="text"><![CDATA[一、前言想要构建一个 React App ，第一步你要完成Reactjs学习计划表。二、需求在本地搭建react开发环境，并构建简单的todolist项目，内容包含但不限于以下内容，界面自行设计：添加 todo ；删除 todo ；修改 todo ；使用localstorage做todo数据存储。三、准备来到这一步，相信你已经完成基本学习了，那么我们把脚手架工具 create-react-app 搭起来：全局安装脚手架工具1npm install -g create-react-app创建一个app1create-react-app myapp进入开发目录1cd myapp安装依赖1npm installpackage.json 文件12345678910111213141516&#123; "name": "myapp", "version": "0.1.0", "private": true, "dependencies": &#123; "react": "^16.2.0", "react-dom": "^16.2.0", "react-scripts": "1.0.17" &#125;, "scripts": &#123; "start": "react-scripts start", // 以开发环境跑起项目 "build": "react-scripts build", // 构建打包项目到生产目录 "test": "react-scripts test --env=jsdom", // 以测试模式启动项目 "eject": "react-scripts eject" // 输出完整包括 Webpack 配置的项目目录（不可逆操作） &#125;&#125;启动项目1npm start四、这么来设计我们的 React 目录结构初始目录：myapp├─ .DS_Store├─ .gitignore├─ README.md├─ package.json├─ public│ ├─ favicon.ico│ ├─ index.html│ └─ manifest.json└─ src├─ App.css├─ App.js├─ App.test.js├─ index.css├─ index.js├─ logo.svg└─ registerServiceWorker.js设计后目录：my-app├─ .gitignore├─ README.md├─ package.json├─ public│ ├─ favicon.ico│ ├─ index.html│ └─ manifest.json└─ src├─ App.css├─ App.js├─ App.test.js├─ actionCreators│ └─ index.js├─ bootstrap.min.css├─ components│ ├─ List.js│ ├─ Nav.js│ ├─ btn│ └─ popup├─ configs│ ├─ actionTypes.js│ └─ index.js├─ index.css├─ index.js├─ logo.svg├─ reducers│ └─ index.js├─ registerServiceWorker.js├─ store│ └─ index.js└─ utils├─ index.js└─ localcache.js设计后的 package.json :1234567891011121314151617181920212223&#123; "name": "my-app", "version": "0.1.0", "private": true, "dependencies": &#123; "immutable": "^3.8.2", "react": "^16.2.0", "react-dom": "^16.2.0", "react-redux": "^5.0.6", "react-scripts": "1.0.17", "redux": "^3.7.2", "redux-thunk": "^2.2.0" &#125;, "scripts": &#123; "start": "react-scripts start", "build": "react-scripts build", "test": "react-scripts test --env=jsdom", "eject": "react-scripts eject" &#125;, "devDependencies": &#123; "redux-devtools": "^3.4.1" &#125;&#125;设计简析：新增了 utils ：操作 localStorage 的增（ create ）、查（ retrieve ）、改（ update ）、删（ delete ）、撤销删除（ recover ）、完成（ done ）；新增了 configs ：配置 action type 的名称；新增了 components ：组件；新增了 actionCreators ：设置 action 的 type 和 payload ；新增了 reducers ：将 reducers 进行拆分操作，再合并暴露给外部；新增了 store.js ：新建 store 并注入中间件；五、利用 Redux 解决组件间通信问题Provider通过 react-redux 引入高阶组件 Provider ，用 Provider 包裹根组件，将 store 注入到所有子组件，如此一来组件间的通信问题就得以解决了：123&lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt;&lt;/Provider&gt;connect但是这么做有个问题：每一个组件需要的 store 不相同，注入全部并不优雅，此时我们引入了 connect ，动态地输出组件需要的（最小）属性：1234567891011// 将从 store 得到 state 按需映射成 props 传入组件，对应的 actions 也做同样的处理；这就是 connect 的作用：作用：连接 React 组件与 Redux storeconnect([mapStateToProps], [mapDispatchToProps], [mergeProps],[options]) // connet 连接 React 组件与 Redux storeexport default connect(state =&gt; &#123; return &#123; dialogStatus: state.ui.get('dialogStatus') &#125;&#125;, &#123; modifyDialog&#125;)(List);六、利用 React-Router 处理路由问题BrowserRouter包裹着根组件，对路由整体做配置；Switch根据子组件 Route 对路由进行切换，按照子组件上不同的属性应用不同的规则，显示不用的页面；可以包含的其他子组件还有 Redirect ；Route主要用到以下几个属性：path ：路由匹配的路径；render ：渲染的内容；exact ：严格匹配当前的 path ；七、总结本篇主要偏向实际应用，对于各项框架的 API 的使用和原理不作详细的描述；附上 demo ： react-work.zip 。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当我们谈论React时，我们谈论些什么？]]></title>
    <url>%2F2018%2F01%2F09%2F%E5%BD%93%E6%88%91%E4%BB%AC%E8%B0%88%E8%AE%BAReact%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E8%B0%88%E8%AE%BA%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前言当我们谈论react，我们会谈论些什么？或许你没用过react，但是你应该或多或少听过一些关于react的名词：虚拟DOM，differ算法，生命周期等。这些名词究竟是什么意思，看完本文，希望你会有答案。 一、react 是什么？React是一个构造可组合式用户界面的库。它鼓励创建可重用的UI组件显示会随着时间而改变的数据。二、react设计的特点?1、组件化的思想，将UI上功能相对独立的模块定义成组件，将小的组件通过组合或嵌套构造成大的组件，完成整体UI的构建，这意味着组件是高度可重用的。2、虚拟DOM和数据单向绑定机制决定了react的响应很快。3、并非一个完整的MVVM框架，它是一个纯V层框架，需要数据流的支撑（例如Redux）处理行为对应的响应。三、react为什么响应快？假如现在你需要写一个像下面一样的表格的应用程序，这个表格可以根据不同的字段进行升序或者降序的展示图3-1：例子我们主要从状态维护和视图更新去看看MVC模式和MVVM模式实现的思路：MVC: 给表格头部加点击事件，用户的点击特定的表头，对比表格里面的内容进行排序,然后用 JS 或者 jQuery 操作 DOM，更新页面的排序状态（表头的那几个箭头表示当前排序状态，也需要更新）和表格内容。随着表格越来越复杂，需要进行监听的事件及更新dom的操作越来越多，代码难以维护。MVVM: 模版中声明视图组件是和什么状态进行绑定的，双向绑定引擎就会在状态更新的时候自动更新视图，大大降低维护状态 -&gt; 视图的复杂程度。一旦状态发生了变化，就用模版引擎重新渲染整个视图，然后用新的视图更换掉旧的视，但是这样一来，即使一个小小的状态变更都要重新构造整棵 DOM，性价比太低，对于大型视图来说，更是不可取。React: 在维护状态这方面上，react也是mvvm的做法，但是在更新视图层上，react另辟蹊径，使用了Virtual DOM，加了一些特别的步骤来避免了整棵 DOM 树变更。虚拟DOM算法是React性能优于其它框架的关键因素，那么什么是虚拟DOM? 怎么用虚拟Dom算法实现Dom树的更新？我们有必要从React的生命周期聊起。四、react的状态更新 4.1 何时触发组件状态更新？和vue类似的，React组件的生命周期分成三个状态： Mounting，Updating和Unmounting。Mounting：组件被render解析生成对于DOM节点并插入浏览器DOM结构的过程Updating：一个已经mouted的组件被重新render的过程。Unmounting：一个已经mouted的组件被从DOM结构中移除的过程。每个状态，React都封装了对应的钩子函数，如下图：图4-1：组件生命周期钩子函数我们关心组件状态的更新过程，发生在Updating这个过程。如上，当state和props发生变化时，会来到图中的函数①接受到变化，函数②会判断组件是否需要更新（如图红色方框）：组件不需要更新：函数②返回false，终止掉Updating的过程，组件需要更新：函数②返回true，继续触发钩子函数③，进行重新render()，更新视图。在这个过程，react是如何判读组件是否需要更新的？下面将隆重请出我们的Virtual DOM算法出场。4.2 为什么使用Virtual DOM事实上，DOM是很慢的，如果我们把一个简单元素DIV的属性都打印出来，可以看到有这么多东西：图4-2：Dom元素属性信息这一坨密密麻麻的属性说明了什么？说明了，DOM 元素非常庞大。这意味着，当一个页面的Dom结构比较复杂的时候，操作它们的时候你要小心翼翼，轻微的触碰可能就会导致页面重排，这可是杀死性能的罪魁祸首。相对于 DOM 对象，原生的 JavaScript 对象处理起来更快，而且更简单。DOM 树上的结构、属性信息我们都可以很容易地用 JavaScript 对象表示出来。以下代码片段是用Javascript对象表示一个列表的属性及节点的信息：1234567891011var element = &#123; tagName: 'ul', // 节点标签名 props: &#123; // DOM的属性，用一个对象存储键值对 id: 'list' &#125;, children: [ // 该节点的子节点 &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: ["Item 1"]&#125;, &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: ["Item 2"]&#125;, &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: ["Item 3"]&#125;, ]&#125;Virtual DOM 算法的原理主要包括以下步骤：1. 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中。 2. 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异。 3. 把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了。 本质就是，在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存。既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM），如图：图4-2：虚拟Dom的作用上面说的步骤一与步骤三不难理解，问题是Virtual DOM如何对比新的树和旧的树的差异呢？这是Virtual DOM最核心的部分—differ算法。4.3 differ算法前面我们说过，React的应用是由众多组件组合或嵌套构建起来的完整的树。所以，比较要比较新树和旧树的差异，就可以从三个层面来比较：树之间的差异：Tree differ组件之间的差异：Component diff组件内的差异：Element diff4.3.1 Tree differ计算一棵树形结构转换成另一棵树形结构的最少操作，是一个复杂且值得研究的问题.传统 diff 算法通过循环递归对节点进行依次对比,算法复杂度达到 O(n^3),其中 n 是树中节点的总数。O(n^3) 到底有多可怕，这意味着如果要展示1000个节点，就要依次执行上十亿次的比较。这种指数型的性能消耗对于前端渲染场景来说代价太高了！ CPU 每秒钟能执行大约30亿条指令，即便是最高效的实现，也不可能在一秒内计算出差异情况。由于Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计，所以React制定大胆的策略：干脆忽略跨层级的比较，两棵树只会对同一层次的节点进行比较。如下图：图4-3：只对比同级的差异只会对相同颜色方框内的 DOM 节点进行比较。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。但是如果出现了 DOM 节点跨层级的移动操作，如下图，A节点（第二层）被移动了D节点下面（第三层）React diff 会有怎样的表现呢？图4-3：跨层级差异当根节点发现子节点中 A 消失了，就会直接销毁 A；当 D 发现多了一个子节点 A，则会创建新的 A（包括子节点）作为其子节点。此时，React diff 的执行情况：create A -&gt; create B -&gt; create C -&gt; delete A由此可发现：当出现节点跨层级移动时，并不会出现想象中的移动操作，而是以 A 为根节点的树被整个重新创建，这是一种影响 React 性能的操作，因此 React 官方建议不要进行 DOM 节点跨层级的操作。注意：在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，可以通过 CSS 隐藏或显示节点，而不是真的移除或添加 DOM 节点。4.3.2 Component diffReact 对于组件间的比较所采取的策略如下：如果是相同组件，进一步比较** 组件内的元素**是否发生变化（Element diff）。 如果不是相同组件，则将该组件判断为 dirty component，从而** 替换整个组件下的所有子节点** 。 如图，左边树的D组件换成了右边新树的G组件，React直接替换掉D组件的所有节点。图4-3：不同组件的差异策略4.2.2.2 Element diff当节点处于同一层级时，React diff 提供了三种节点操作：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。 插入与删除很好理解，如下图，老集合中包含节点：A、B、C、D，更新后的新集合中包含节点：B、A、D、C。图4-2：插入和删除此时新老集合进行 diff 差异化对比，发现 B != A，则创建并插入 B 至新集合，删除老集合 A；以此类推，创建并插入 A、D 和 C，删除 B、C 和 D。React 发现这类操作繁琐冗余，因为这些都是相同的节点，但由于位置发生变化，导致需要进行繁杂低效的删除、创建操作，其实只要对这些节点进行位置移动即可。针对这一现象，React 提出优化策略：对同一层级的同组子节点，添加唯一 key 进行区分。 新老集合所包含的节点，如下图所示，新老集合进行 diff 差异化对比，通过 key 发现新老集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将老集合中节点的位置进行移动，更新为新集合中节点的位置，此时 React 给出的 diff 结果为：B、D 不做任何操作，A、C 进行移动操作，即可。新老集合所包含的节点，如下图所示，新老集合进行 diff 差异化对比，通过 key 发现新老集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将老集合中节点的位置进行移动，更新为新集合中节点的位置，此时 React 给出的 diff 结果为：B、D 不做任何操作，A、C 进行移动操作，即可。图4-2：移动操作 总结以上，就是关于React虚拟Dom及Differ算法的简单介绍。总而言之， 虚拟Dom的原理就是先用JavaScript表示Dom结构（实际中是使用React提供的语法糖JSX来写），构建出一颗真正的Dom树插入文档中。当Dom树发生变化时，React会重新构造一个新的虚拟树，将新树和旧树做对比，有差异则重新渲染视图。好了，通过这么一番介绍，你是否对一些关于React的名词有了进一步的认识呢？]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Gulp插件开发]图片智能转换Base64格式]]></title>
    <url>%2F2018%2F01%2F08%2FGulp%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-Base64%E6%A0%BC%E5%BC%8F%E5%9B%BE%E7%89%87%E6%99%BA%E8%83%BD%E8%BD%AC%E6%8D%A2%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言我们为什么要使用Base64格式图片？Base64是网上常见的用于传输8bit字节码的编码方式之一，通俗讲就是一种基于64种可打印字符来表示二进制数据的方法。使用Base64字符替换传统的URL图片链接，其中一个便是起到加密作用。一串无规则的字符，使得我们的文件路径信息得到较好的隐藏。其次是减少一次http的请求，加快页面渲染速度，起到优化性能的作用。BTW，凡是都具有两面性，使用base64转换的图片，是一串较长的编码字符，这在一定程度上会加大文件体积。因此，我们一般只针对体积较小的图片做base64的转化，该插件则默认将3kb内的图片转化为base64格式。插件功能Func One: 遍历模板文件（HTML/TPL）中的img标签图片，智能地对其做Base64的处理。处理后的效果如图：图2-1：gulp-imgs2base64插件处理html效果图Func Two: 遍历样式表文件（CSS）中的背景图片，智能地对其做Base64的处理。处理后的效果如图：图2-2：gulp-img2base64插件处理CSS效果图UsageSTEP 1安装插件：1npm install gulp-img-base64STEP 2gulpfile.js中引用文件：123456789101112// 引入base64插件const base64Img = require('./gulp-img-base64');// 注册gulp任务gulp.task('default', () =&gt; &#123; gulp.src('./html/*.css') .pipe(base64Img(&#123; size: 3000, baseUrl: __dirname + '/src/' &#125;)) .pipe(gulp.dest('build'));&#125;)API说明：size: [可选]图片智能转换位base64格式的边界值，一般为3000，单位KbaseUrl: [必须]图片源文件所在根目录如何开发Gulp-img-base64插件原理插件工作流图如下：图4-1：gulp-imgs2base64插件流程图gulp插件开发gulp 插件总是返回一个_object mode_形式的 stream 来做这些事情：接收 vinyl File 对象输出 vinyl File 对象这通常被叫做 transform streams (有时候也叫做 through streams)。transform streams 是可读又可写的，它会对传给它的对象做一些转换的操作。而在我们实际的插件开发中，我们会使用一个through2的插件，这是一个对 node 的 transform streams 简单封装的插件，我们在引用这个插件之后，直接在API through.obj中操作gulp文件流即可，简单清晰，如下代码：1234567891011121314151617181920module.exports = function(options) &#123; // 创建一个让每个文件通过的 stream 通道 return through.obj(function(file, enc, done) &#123; if (file.isNull()) &#123; done(null, file); // 返回空文件 &#125; if (file.isStream()) &#123; this.emit('error', new PluginError(PLUGIN_NAME, 'Streams are not supported!')); return done(); &#125; if (file.isBuffer()) &#123; // 操作buffer文件流 &#125; // 确保文件进去下一个插件 done(null, file, enc); &#125;);&#125;源码附件gulp-imgs2base64]]></content>
      <categories>
        <category>开发工作流</category>
      </categories>
      <tags>
        <tag>gulp</tag>
        <tag>base64</tag>
        <tag>image</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[37海外前端Blog规范]]></title>
    <url>%2F2017%2F12%2F21%2FBlog-Test%2F</url>
    <content type="text"><![CDATA[如何归属文章文章的分类一般有两个维度：分类和标签。一般而言，分类项由博客委员会成员确立，各成员发表的博客都应该归类于此。目前包含的分类有：前端开发NodeJs开发工作流开发规范读书笔记团队生活如需新增分类项，需博客委员会审核通过。标签则是对当前博文所包含属性的一种标记，如JavaScript、https等标签，由博主根据博文情况自行标记。如何使用标题《37海外前端Blog规范》（以下简称为《规范》）中要求，每一篇博文中最多不超过两级标题，两级标题以下的内容，使用加粗的方式进行强调。一级标题的使用一级标题作为博文中最高级别的标题，由4个“#”符号生成。二级标题的使用二级标题作为博文中的最低级别的标题，由5个“#”符号生成。如何使用强调和突出强调和突出主要表现在文字的正斜体，文字颜色和粗细三方面。《规范》规定，博文中文字部分的强调突出限定于以下三种方式：使用2个“*”或“_”符号加粗使用红色（color=red）使用1个“_”符号倾斜说明：在博文的实际书写过程，可以将以上三种方式任意结合，达成不同的强调效果。如何使用代码JavaScript:1var name = "wilton"; // 这是javascript的代码，支持语法高亮的哦HTML:12&lt;!-- html代码也可以语法高亮的哦 --&gt;&lt;div class="box" id="J_box"&gt;这是测试的html标签&lt;/div&gt;CSS:12345/* css代码也可以高亮的哦 */.box&#123; display: -webkit-flex; display: flex;&#125;如何使用图片图片的使用包含两个像素：图像和图像说明。《规范》要求图像和图像文字说明均居中显示，文字字号使用3字号，色号使用“#777”，说明格式为：图[一级标题所在编号]-[该级标题下图片编号]:[具体说明]。如 图5-1:念慈小姐姐哦图5-1：念慈小姐姐哦博文发表流程团队成员在博文发表过程需要经过一下流程：博主新建博文开发分支博主依据相关规范书写博文并做本地调试提交博客委员会审核审核通过则执行下一步，否则返回第二步合并博文源码并发布博文具体流程图如下：图6-1：博文发表流程图附录：Markdown语法参考]]></content>
      <categories>
        <category>开发规范</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new "My New Post"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment]]></content>
  </entry>
</search>
